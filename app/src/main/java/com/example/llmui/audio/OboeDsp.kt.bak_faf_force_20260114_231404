package com.example.llmui.audio

import com.example.lowlatencymonitor.audio.AudioEngine

/**
 * DAF oparty o AudioEngine (Oboe) z LowLatencyMonitor.
 *
 * Założenia:
 *  - 0 ms  = DAF wyłączony (mix=0, fb=0),
 *  - 60–220 ms = użyteczny zakres DAF,
 *  - presety MicDspPreset (NEUTRAL, SMOOTH, DYNAMIC) zmieniają charakter miksu i głośność.
 */
object OboeDsp {

    private const val GAIN_PARAM_GAIN = 0
    private const val DELAY_PARAM_TIME_MS = 0
    private const val DELAY_PARAM_FEEDBACK = 1
    private const val DELAY_PARAM_MIX = 2
    private const val FAF_PARAM_PITCH_RATIO = 0
    private const val FAF_PARAM_MIX = 1

    private var started = false
    private var gainNode = -1
    private var delayNode = -1

    private var currentGain = 1.0f
    private var currentDelayMs = 0
    private var feedbackEnabled = false

    // aktualny preset DSP (enum jest w MicDspPreset.kt)
    private var currentMicPreset: MicDspPreset = MicDspPreset.NEUTRAL

    private var fafNode = -1
    private var fafPitchRatio = 1.0f
    private var fafMix = 0.0f

    fun start(): Boolean {
        if (started) return true
        return try {
            AudioEngine.start()
            AudioEngine.clearChain()

            // GAIN
            gainNode = AudioEngine.addNode("gain")
            if (gainNode >= 0) {
                AudioEngine.setParam(gainNode, GAIN_PARAM_GAIN, currentGain)
            }

            // DELAY (DAF)
            delayNode = AudioEngine.addNode("delay")
            if (delayNode >= 0) {
                AudioEngine.setParam(
                    delayNode,
                    DELAY_PARAM_TIME_MS,
                    currentDelayMs.toFloat()
                )
                applyDelayMix()
            }

            // FAF pitch node (true FAF)
            fafNode = AudioEngine.addNode("faf_pitch")
            if (fafNode >= 0) {
                AudioEngine.setParam(fafNode, FAF_PARAM_PITCH_RATIO, fafPitchRatio)
                AudioEngine.setParam(fafNode, FAF_PARAM_MIX, fafMix)
            }

            started = true
            true
        } catch (_: Throwable) {
            started = false
            false
        }
    }

    fun stop() {
        if (!started) return
        try {
            AudioEngine.stop()
        } catch (_: Throwable) {
        } finally {
            started = false
        }
    }

    fun setDelayMs(value: Int) {
        val clampedUi = value.coerceIn(0, 300)
        currentDelayMs = clampedUi

        if (delayNode >= 0) {
            AudioEngine.setParam(
                delayNode,
                DELAY_PARAM_TIME_MS,
                currentDelayMs.toFloat()
            )
            applyDelayMix()
        }
    }

    fun getMinDelayMs(): Int = 0

    fun getRingDelayMs(): Int = currentDelayMs

    fun setGain(g: Float) {
        val clamped = g.coerceIn(0f, 2f)
        currentGain = clamped
        if (gainNode >= 0) {
            AudioEngine.setParam(gainNode, GAIN_PARAM_GAIN, clamped)
        }
    }

    fun getGain(): Float = currentGain

    fun setFeedbackMode(enabled: Boolean) {
        feedbackEnabled = enabled
        applyDelayMix()
    }

    fun setTestToneEnabled(enabled: Boolean) {
        // brak osobnego generatora tonu w tym silniku – no-op
    }

    /**
     * Ustawienie presetu DSP – wywoływane z DafScreen.
     * Każdy preset ustawia swój typowy GAIN + charakter miksu.
     */
    fun setMicPreset(preset: MicDspPreset) {
        currentMicPreset = preset
        applyMicPresetGain()
        applyDelayMix()
    }

    // --- Prywatne ---

    private fun applyMicPresetGain() {
        // wyraźne różnice głośności, ale wciąż w bezpiecznym zakresie
        val targetGain = when (currentMicPreset) {
            MicDspPreset.NEUTRAL -> 1.0f   // bazowy, jak „stara dobra” wersja
            MicDspPreset.SMOOTH  -> 0.8f   // trochę ciszej, łagodniej
            MicDspPreset.DYNAMIC -> 1.3f   // trochę głośniej, bardziej „na twarz”
        }

        currentGain = targetGain
        if (gainNode >= 0) {
            AudioEngine.setParam(gainNode, GAIN_PARAM_GAIN, targetGain)
        }
    }

    private fun applyDelayMix() {
        if (delayNode < 0) return

        if (!feedbackEnabled || currentDelayMs <= 0) {
            // DAF wyłączony
            AudioEngine.setParam(delayNode, DELAY_PARAM_FEEDBACK, 0f)
            AudioEngine.setParam(delayNode, DELAY_PARAM_MIX, 0f)
            return
        }

        // Przy włączonym DAF zawężamy zakres do 60–220 ms
        val effectiveMs = currentDelayMs.coerceIn(60, 220)
        AudioEngine.setParam(
            delayNode,
            DELAY_PARAM_TIME_MS,
            effectiveMs.toFloat()
        )

        // Wyraźnie różne miksy:
        //  NEUTRAL – 0.60 (to co znałeś),
        //  SMOOTH  – 0.45, delikatniejszy odsłuch,
        //  DYNAMIC – 0.80, mocniejszy efekt.
        val (fb, mix) = when (currentMicPreset) {
            MicDspPreset.NEUTRAL -> 0.0f to 0.60f
            MicDspPreset.SMOOTH  -> 0.0f to 0.45f
            MicDspPreset.DYNAMIC -> 0.0f to 0.80f
        }

        AudioEngine.setParam(delayNode, DELAY_PARAM_FEEDBACK, fb)
        AudioEngine.setParam(delayNode, DELAY_PARAM_MIX, mix)
    }
    // ===== FAF API =====

    /**
     * Ustawia współczynnik pitch (1.0 = brak zmiany,
     *  <1 niżej, >1 wyżej; zakres 0.8..1.2)
     */
    fun setFafPitchRatio(ratio: Float) {
        val clamped = ratio.coerceIn(0.6f, 1.5f)
        fafPitchRatio = clamped
        if (fafNode >= 0) {
            AudioEngine.setParam(fafNode, FAF_PARAM_PITCH_RATIO, clamped)
        }
    }

    /**
     * Ustawia miks FAF (0.0 = tylko normalny głos, 1.0 = tylko FAF).
     */
    fun setFafMix(mix: Float) {
        val clamped = mix.coerceIn(0f, 1f)
        fafMix = clamped
        if (fafNode >= 0) {
            AudioEngine.setParam(fafNode, FAF_PARAM_MIX, clamped)
        }
    }

    fun getFafPitchRatio(): Float = fafPitchRatio
    fun getFafMix(): Float = fafMix

}

